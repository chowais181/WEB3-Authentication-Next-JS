{"version":3,"file":"react-query.production.min.js","sources":["../src/core/subscribable.ts","../src/core/utils.ts","../src/core/focusManager.ts","../src/core/onlineManager.ts","../src/core/retryer.ts","../src/core/logger.ts","../src/core/notifyManager.ts","../src/core/removable.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/mutation.ts","../src/core/mutationCache.ts","../src/core/infiniteQueryBehavior.ts","../src/core/queryObserver.ts","../src/core/queriesObserver.ts","../src/core/infiniteQueryObserver.ts","../src/core/mutationObserver.ts","../src/core/hydration.ts","../src/reactjs/QueryClientProvider.tsx","../src/reactjs/QueryErrorResetBoundary.tsx","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../src/reactjs/useSyncExternalStore.ts","../src/reactjs/utils.ts","../src/reactjs/isRestoring.tsx","../src/reactjs/useBaseQuery.ts","../src/reactjs/Hydrate.tsx","../src/core/queryClient.ts","../src/reactjs/useInfiniteQuery.ts","../src/reactjs/useIsFetching.ts","../src/reactjs/useIsMutating.ts","../src/reactjs/useMutation.ts","../src/reactjs/useQueries.ts","../src/reactjs/useQuery.ts"],"sourcesContent":["type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.push(listener as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter(x => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, queryKey: arg1 }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, mutationKey: arg1 }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void\n) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        window.addEventListener('online', listener, false)\n        window.addEventListener('offline', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener)\n          window.removeEventListener('offline', listener)\n        }\n      }\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => void\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch(error => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn?.()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = callback => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends Function>(callback: T): T => {\n    return ((...args: any[]) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }) as any\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  cacheTime!: number\n  private gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  protected updateCacheTime(newCacheTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      newCacheTime ?? (isServer ? Infinity : 5 * 60 * 1000)\n    )\n  }\n\n  protected clearGcTimeout() {\n    clearTimeout(this.gcTimeout!)\n    this.gcTimeout = undefined\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n  QueryMeta,\n  CancelOptions,\n  SetDataOptions,\n  FetchStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport { defaultLogger, Logger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Retryer, isCancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n  meta: QueryMeta | undefined\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n  meta: QueryMeta | undefined\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: QueryState<TData, TError>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  meta: QueryMeta | undefined\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.meta = config.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.meta = options?.meta\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean }\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: QueryState<TData, TError>,\n    setStateOptions?: SetStateOptions\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(observer => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some(observer => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn')\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: data => {\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined') as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: state.fetchFailureCount + 1,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasInitialData = typeof options.initialData !== 'undefined'\n\n  const initialDataUpdatedAt = hasInitialData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  const hasData = typeof data !== 'undefined'\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n","import {\n  QueryFilters,\n  hashQueryKeyByOptions,\n  matchQuery,\n  parseFilterArgs,\n} from './utils'\nimport { Action, Query, QueryState } from './query'\nimport type { QueryKey, QueryOptions } from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ntype QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta,\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter(x => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueyKey extends QueryKey = QueryKey\n  >(\n    queryHash: string\n  ): Query<TQueryFnData, TError, TData, TQueyKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find(query => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter(query => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import type { MutationOptions, MutationStatus, MutationMeta } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport { defaultLogger, Logger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { canFetch, Retryer, createRetryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n  meta: MutationMeta | undefined\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.options = {\n      ...config.defaultOptions,\n      ...config.options,\n    }\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n    this.meta = config.meta\n\n    this.updateCacheTime(this.options.cacheTime)\n    this.scheduleGc()\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<TData> {\n    if (this.retryer) {\n      this.retryer.continue()\n      return this.retryer.promise\n    }\n    return this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: () => {\n          this.dispatch({ type: 'failed' })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: state.failureCount + 1,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n","import { MutationObserver } from './mutationObserver'\nimport type { MutationOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport { Action, Mutation, MutationState } from './mutation'\nimport { matchMutation, MutationFilters, noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>\n  ) => void\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>\n  ) => void\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown, unknown>\n  ) => void\n}\n\ninterface NotifyEventMutationAdded {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationUpdated {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n      meta: options.meta,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter(x => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<void> {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused)\n    return notifyManager.batch(() =>\n      pausedMutations.reduce(\n        (promise, mutation) =>\n          promise.then(() => mutation.continue().catch(noop)),\n        Promise.resolve()\n      )\n    )\n  }\n}\n","import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then(page =>\n            buildNewPages(pages, param, page, previous)\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i])\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n}\n","import { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    )\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    return this.createResult(query, options)\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    clearTimeout(this.staleTimeoutId!)\n    this.staleTimeoutId = undefined\n  }\n\n  private clearRefetchInterval(): void {\n    clearInterval(this.refetchIntervalId!)\n    this.refetchIntervalId = undefined\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdateCount &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = (state.data as unknown) as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            placeholderData = replaceData(\n              prevResult?.data,\n              placeholderData,\n              options\n            )\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = placeholderData as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n\n      if (\n        notifyOnChangeProps === 'all' ||\n        (!notifyOnChangeProps && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(notifyOnChangeProps ?? this.trackedProps)\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect']\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n","import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryObserverOptions,\n  QueryObserverResult,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport { NotifyOptions, QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.observers.forEach(observer => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions\n  ): void {\n    this.queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.observers\n\n      const newObserverMatches = this.findMatchingObservers(this.queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach(match =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions)\n      )\n\n      const newObservers = newObserverMatches.map(match => match.observer)\n      const newObserversMap = Object.fromEntries(\n        newObservers.map(observer => [observer.options.queryHash, observer])\n      )\n      const newResult = newObservers.map(observer =>\n        observer.getCurrentResult()\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index]\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return this.findMatchingObservers(queries).map(match =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions)\n    )\n  }\n\n  private findMatchingObservers(\n    queries: QueryObserverOptions[]\n  ): QueryObserverMatch[] {\n    const prevObservers = this.observers\n    const defaultedQueryOptions = queries.map(options =>\n      this.client.defaultQueryOptions(options)\n    )\n\n    const matchingObservers: QueryObserverMatch[] = defaultedQueryOptions.flatMap(\n      defaultedOptions => {\n        const match = prevObservers.find(\n          observer => observer.options.queryHash === defaultedOptions.queryHash\n        )\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      }\n    )\n\n    const matchedQueryHashes = matchingObservers.map(\n      match => match.defaultedQueryOptions.queryHash\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      defaultedOptions =>\n        !matchedQueryHashes.includes(defaultedOptions.queryHash)\n    )\n\n    const unmatchedObservers = prevObservers.filter(\n      prevObserver =>\n        !matchingObservers.some(match => match.observer === prevObserver)\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.client.defaultQueryOptions(options)\n      const currentObserver = this.observersMap[defaultedOptions.queryHash!]\n      return currentObserver ?? new QueryObserver(this.client, defaultedOptions)\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options, index) => {\n        if (options.keepPreviousData) {\n          // return previous data from one of the observers that no longer match\n          const previouslyUsedObserver = unmatchedObservers[index]\n          if (previouslyUsedObserver !== undefined) {\n            return {\n              defaultedQueryOptions: options,\n              observer: previouslyUsedObserver,\n            }\n          }\n        }\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      }\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","import type {\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport {\n  NotifyOptions,\n  ObserverFetchOptions,\n  QueryObserver,\n} from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions: ObserverFetchOptions\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >,\n    notifyOptions?: NotifyOptions\n  ): void {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior(),\n      },\n      notifyOptions\n    )\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage({ pageParam, ...options }: FetchNextPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  }: FetchPreviousPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, InfiniteData<TQueryData>>,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(options, state.data?.pages),\n      isFetchingNextPage:\n        state.fetchStatus === 'fetching' &&\n        state.fetchMeta?.fetchMore?.direction === 'forward',\n      isFetchingPreviousPage:\n        state.fetchStatus === 'fetching' &&\n        state.fetchMeta?.fetchMore?.direction === 'backward',\n    }\n  }\n}\n","import { Action, getDefaultState, Mutation } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    this.options = this.client.defaultMutationOptions(options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {}\n): DehydratedState {\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach(mutation => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach(query => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state\n    )\n  })\n\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state\n    )\n  })\n}\n","import React from 'react'\n\nimport { QueryClient } from '../core'\nimport { ContextOptions } from '../reactjs/types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext))\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import React from 'react'\n\n// CONTEXT\n\ninterface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","import pkg from 'use-sync-external-store/shim/index.js'\nexport const useSyncExternalStore = pkg.useSyncExternalStore\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","import React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { QueryKey, notifyManager, QueryObserver } from '../core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\nimport { useIsRestoring } from './isRestoring'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions\n      )\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      onStoreChange =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  )\n\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch(error => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(defaultedOptions.useErrorBoundary, [\n      result.error,\n      observer.getCurrentQuery(),\n    ])\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","import React from 'react'\n\nimport { hydrate, HydrateOptions } from '../core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {}\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n","import {\n  QueryFilters,\n  Updater,\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  MutationFilters,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport { defaultLogger, Logger } from './logger'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n  }\n\n  mount(): void {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.unsubscribeFocus?.()\n    this.unsubscribeOnline?.()\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): TData | undefined {\n    return this.queryCache.find<TData>(queryKey, filters)?.state.data\n  }\n\n  getQueriesData<TData = unknown>(queryKey: QueryKey): [QueryKey, TData][]\n  getQueriesData<TData = unknown>(filters: QueryFilters): [QueryKey, TData][]\n  getQueriesData<TData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters\n  ): [QueryKey, TData][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TData\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TData>(\n    queryKey: QueryKey,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: SetDataOptions\n  ): TData | undefined {\n    const query = this.queryCache.find<TData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TData>(\n    queryKey: QueryKey,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: SetDataOptions\n  ): [QueryKey, TData | undefined][]\n\n  setQueriesData<TData>(\n    filters: QueryFilters,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: SetDataOptions\n  ): [QueryKey, TData | undefined][]\n\n  setQueriesData<TData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: SetDataOptions\n  ): [QueryKey, TData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TData>(queryKey, updater, options),\n        ])\n    )\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): QueryState<TData, TError> | undefined {\n    return this.queryCache.find<TData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions))\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter(query => !query.isDisabled())\n        .map(query =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          })\n        )\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<void> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>\n  ): void {\n    const result = this.queryDefaults.find(\n      x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find(x =>\n      partialMatchKey(queryKey, x.queryKey)\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x =>\n        partialMatchKey(queryKey, x.queryKey)\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\n            `[QueryClient] Several query defaults match with key '${JSON.stringify(\n              queryKey\n            )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`\n          )\n        }\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.mutationDefaults.find(\n      x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find(x =>\n      partialMatchKey(mutationKey, x.mutationKey)\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x =>\n        partialMatchKey(mutationKey, x.mutationKey)\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\n            `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n              mutationKey\n            )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`\n          )\n        }\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import { QueryObserver } from '../core'\nimport { InfiniteQueryObserver } from '../core/infiniteQueryObserver'\nimport { QueryFunction, QueryKey } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { ContextOptions } from './types'\nimport { QueryKey, notifyManager } from '../core'\nimport { parseFilterArgs, QueryFilters } from '../core/utils'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      onStoreChange =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache]\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters)\n  )\n}\n","import React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { notifyManager } from '../core/notifyManager'\nimport { MutationKey } from '../core/types'\nimport { ContextOptions } from '../reactjs/types'\nimport { MutationFilters, parseMutationFilterArgs } from '../core/utils'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      onStoreChange =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache]\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters)\n  )\n}\n","import React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { notifyManager } from '../core'\nimport { noop, parseMutationArgs } from '../core/utils'\nimport { MutationObserver } from '../core/mutationObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { MutationFunction, MutationKey } from '../core/types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options\n      )\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      onStoreChange =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer]\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n","import React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { QueryKey, QueryFunction } from '../core/types'\nimport { notifyManager } from '../core/notifyManager'\nimport { QueriesObserver } from '../core/queriesObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = []\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = []\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map(options => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring]\n  )\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries)\n  )\n\n  const result = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      onStoreChange =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  return result as QueriesResults<T>\n}\n","import { QueryObserver } from '../core'\nimport { QueryFunction, QueryKey } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n"],"names":["Subscribable","constructor","listeners","subscribe","this","bind","listener","push","onSubscribe","filter","x","onUnsubscribe","hasListeners","length","isServer","window","noop","isValidTimeout","value","Infinity","difference","array1","array2","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","mutationKey","hashQueryKey","status","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","array","Array","isArray","aSize","bItems","bSize","copy","equalItems","i","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","forEach","isFocused","document","includes","visibilityState","onlineManager","onOnline","online","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","isRetryCancelled","continueFn","promiseResolve","promiseReject","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","schedule","flush","originalQueue","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","initialDataUpdatedAt","hasData","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","fetchFn","context","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","isFetchingOptimistic","_this$cache$config$on2","_this$cache$config2","Error","action","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","event","Mutation","mutationId","mutationCache","execute","async","executeMutation","_this$options$retry","mutationFn","variables","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","onSettled","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onError","_this$options4","_this$options$onSettl2","_this$options5","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryObserver","trackedProps","Set","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","getQueryCache","createResult","currentResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","_fetchOptions$cancelR","throwOnError","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectFn","selectResult","placeholderData","isFetching","isLoading","isError","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","shallowEqualObjects","defaultNotifyOptions","notifyOnChangeProps","size","includedProps","useErrorBoundary","typedKey","has","shouldNotifyListeners","shouldLoadOnMount","retryOnMount","refetchOnMount","field","suspense","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newObserversMap","fromEntries","newResult","hasIndexChange","index","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","concat","slice","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","MutationObserver","mutate","_this$currentMutation","currentMutation","mutateOptions","getMutationCache","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","hydrate","dehydratedState","queryCache","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","defaultContext","React","createContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","useContext","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","e","require","k","is","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","d","f","u","createElement","inst","c","g","exports","useSyncExternalStore","module","shouldThrowError","_useErrorBoundary","params","IsRestoringContext","useIsRestoring","useBaseQuery","Observer","isRestoring","errorResetBoundary","useCallback","onStoreChange","useHydrate","optionsRef","useRef","current","useMemo","Provider","children","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isMutating","getQueryData","_this$queryCache$find","getQueriesData","queryKeyOrFilters","setQueryData","updater","input","functionalUpdate","parsedOptions","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","Context","dehydrateMutations","shouldDehydrateMutation","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","parseMutationFilterArgs","parseMutationArgs","mutateAsync","defaultedQueries"],"mappings":"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"}